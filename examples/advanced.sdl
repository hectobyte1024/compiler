// Advanced SDL Shader Example demonstrating full language features

// Vertex shader with variables, functions, and control flow
shader advancedVertex : vertex {
    in vec3 position;
    in vec3 normal;
    in vec2 texCoord;
    
    out vec3 worldPos;
    out vec3 worldNormal;
    out vec2 vTexCoord;
    
    uniform mat4 modelMatrix;
    uniform mat4 viewMatrix;
    uniform mat4 projectionMatrix;
    uniform mat3 normalMatrix;
    
    vec3 transformPosition(vec3 pos) {
        vec4 worldPosition = modelMatrix * vec4(pos, 1.0);
        return worldPosition.xyz;
    }
    
    vec3 transformNormal(vec3 norm) {
        return normalize(normalMatrix * norm);
    }
    
    void main() {
        worldPos = transformPosition(position);
        worldNormal = transformNormal(normal);
        vTexCoord = texCoord;
        
        vec4 viewPos = viewMatrix * vec4(worldPos, 1.0);
        gl_Position = projectionMatrix * viewPos;
        
        // Example control flow
        if (position.y > 0.0) {
            vTexCoord = vTexCoord * 2.0;
        } else {
            vTexCoord = vTexCoord * 0.5;
        }
    }
}

// Fragment shader with lighting calculations
shader advancedFragment : fragment {
    in vec3 worldPos;
    in vec3 worldNormal;
    in vec2 vTexCoord;
    
    out vec4 fragColor;
    
    uniform sampler2D diffuseTexture;
    uniform sampler2D normalTexture;
    uniform vec3 lightPosition;
    uniform vec3 cameraPosition;
    uniform float roughness;
    uniform float metallic;
    
    vec3 calculateLighting(vec3 albedo, vec3 normal, vec3 viewDir, vec3 lightDir) {
        float NdotL = max(dot(normal, lightDir), 0.0);
        vec3 diffuse = albedo * NdotL;
        
        vec3 halfVector = normalize(lightDir + viewDir);
        float NdotH = max(dot(normal, halfVector), 0.0);
        float specular = pow(NdotH, 32.0);
        
        return diffuse + vec3(specular);
    }
    
    void main() {
        vec3 albedo = texture(diffuseTexture, vTexCoord).rgb;
        vec3 normal = normalize(worldNormal);
        
        vec3 viewDir = normalize(cameraPosition - worldPos);
        vec3 lightDir = normalize(lightPosition - worldPos);
        
        vec3 color = calculateLighting(albedo, normal, viewDir, lightDir);
        
        // Example loop
        for (int i = 0; i < 3; i = i + 1) {
            color = color * 1.1;
        }
        
        fragColor = vec4(color, 1.0);
    }
}

// Compute shader for image processing
shader imageBlur : compute {
    uniform sampler2D inputImage;
    uniform vec2 imageSize;
    uniform float blurRadius;
    
    vec4 sampleBlur(vec2 coord) {
        vec4 color = vec4(0.0);
        float totalWeight = 0.0;
        
        int radius = int(blurRadius);
        for (int x = -radius; x <= radius; x = x + 1) {
            for (int y = -radius; y <= radius; y = y + 1) {
                vec2 offset = vec2(float(x), float(y)) / imageSize;
                vec2 sampleCoord = coord + offset;
                
                if (sampleCoord.x >= 0.0 && sampleCoord.x <= 1.0 &&
                    sampleCoord.y >= 0.0 && sampleCoord.y <= 1.0) {
                    
                    float weight = 1.0;
                    color = color + texture(inputImage, sampleCoord) * weight;
                    totalWeight = totalWeight + weight;
                }
            }
        }
        
        return color / totalWeight;
    }
    
    void main() {
        vec2 coord = vec2(gl_GlobalInvocationID.xy) / imageSize;
        vec4 blurredColor = sampleBlur(coord);
        
        // Store result (conceptual - actual implementation would use imageStore)
        // imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), blurredColor);
    }
}
